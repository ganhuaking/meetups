{
    "componentChunkName": "component---node-modules-gatsby-theme-primer-wiki-src-templates-post-query-js",
    "path": "/HTTP/1.1/",
    "result": {"data":{"mdx":{"id":"f54c4557-fb52-5b45-b971-371a97b5587a","tableOfContents":{},"fields":{"title":"1.1","slug":"/HTTP/1.1/","url":"https://meetups.ganhuaking.tw/HTTP/1.1/","editUrl":"https://github.com/ganhuaking/meetups/tree/main/HTTP/1.1.md","lastUpdatedAt":"2023-01-02T17:29:44.000Z","lastUpdated":"1/2/2023","gitCreatedAt":"2023-01-02T17:29:44.000Z","shouldShowTitle":true},"frontmatter":{"title":"","description":null,"imageAlt":null,"tags":[],"date":null,"dateModified":null,"language":null,"seoTitle":null,"image":null},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://datatracker.ietf.org/doc/html/rfc2616\"\n  }, \"HTTP 1.1\"), \" \\uFF0C\\u4EE5\\u4E0B\\u7B46\\u8A18\\u662F\\u53C3\\u8003 \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://datatracker.ietf.org/doc/html/rfc7231\"\n  }, \"RFC 7231\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"1997 \\u767C\\u5E03\\u7B2C\\u4E00\\u7248\\uFF0C1999 \\u767C\\u5E03\\u4E86\\u7B2C\\u4E8C\\u7248\\uFF0C\\u4E5F\\u662F\\u7528\\u4E86 10 \\u591A\\u5E74\\u4E4B\\u4E45\\u7684 HTTP 1.1\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result.\"), mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Method token \\u6307\\u51FA\\u4E86 client \\u7684\\u76EE\\u7684\\uFF0C\\u540C\\u6642\\u5B83\\u4E5F\\u80FD\\u9810\\u671F client \\u80FD\\u62FF\\u5F97\\u5230\\u7684\\u7D50\\u679C\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Method token \\u76EE\\u524D\\u8A0E\\u8AD6\\u8D77\\u4F86\\uFF0C\\u611F\\u89BA\\u6BD4\\u8F03\\u50CF URI\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The request method's semantics might be further specialized by the semantics of some header fields when present in a request (Section 5) if those additional semantics do not conflict with the method.  For example, a client can send conditional request header fields (Section 5.2) to make the requested action conditional on the current state of the target resource (\", \"[RFC7232]\", \").\"), mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u67D0\\u4E9B Header \\u8A9E\\u6CD5\\u53EA\\u8981\\u4E0D\\u8DDF Method \\u885D\\u7A81\\uFF0C\\u5B83\\u90FD\\u6709\\u53EF\\u80FD\\u6703\\u5F71\\u97FF\\u884C\\u70BA\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u50CF IF-MATCH \\u4E4B\\u985E\\u7684\\u8A71\\u6CD5\\uFF0C\\u6703\\u8DDF\\u76EE\\u6A19\\u8CC7\\u6E90\\u7684\\u72C0\\u614B\\u6709\\u95DC\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"HTTP was originally designed to be usable as an interface to distributed object systems.  The request method was envisioned as applying semantics to a target resource in much the same way as invoking a defined method on an identified object would apply semantics.  The method token is case-sensitive because it might be used as a gateway to object-based systems with case-sensitive method names.\"), mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"HTTP \\u662F\\u88AB\\u8A2D\\u8A08\\u7D66\\u5206\\u6563\\u5F0F\\u7269\\u4EF6\\u7CFB\\u7D71\\u5B58\\u53D6\\u7684\\u4ECB\\u9762\\uFF0C\\u800C method \\u6307\\u7684\\u662F\\u6703\\u61C9\\u7528\\u5728\\u8CC7\\u6E90\\u4E0A\\u7684\\u65B9\\u6CD5\\u3002\\u9019\\u5C31\\u8DDF\\u5728\\u67D0\\u500B\\u985E\\u5225\\u4E0A\\u76F4\\u63A5\\u5B9A\\u7FA9 method \\u4E26\\u547C\\u53EB\\u975E\\u5E38\\u50CF\\u3002\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Unlike distributed objects, the standardized request methods in HTTP are not resource-specific, since uniform interfaces provide for better visibility and reuse in network-based systems \", \"[REST]\", \".  Once defined, a standardized method ought to have the same semantics when applied to any resource, though each resource determines for itself whether those semantics are implemented or allowed.\"), mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u8DDF\\u7269\\u4EF6\\u4E0D\\u4E00\\u6A23\\u7684\\u662F\\uFF0CHTTP \\u7684\\u8ACB\\u6C42\\u65B9\\u6CD5\\u4E26\\u4E0D\\u662F\\u4F9D\\u8CF4\\u65BC\\u8CC7\\u6E90\\u7684\\u7279\\u6027\\uFF0C\\u56E0\\u70BA\\u4ECB\\u9762\\u7D71\\u4E00\\u5728\\u7DB2\\u8DEF\\u7CFB\\u7D71\\u4E0A\\u6703\\u6709\\u66F4\\u597D\\u7684\\u53EF\\u898B\\u6027\\u548C\\u91CD\\u7528\\u6027\\uFF08\\u53C3\\u8003 REST\\uFF09\\u3002\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u4E00\\u500B\\u7D71\\u4E00\\u7684\\u65B9\\u6CD5\\uFF0C\\u61C9\\u7528\\u5728\\u4EFB\\u4F55\\u8CC7\\u6E90\\u61C9\\u8A72\\u90FD\\u5177\\u6709\\u76F8\\u540C\\u7684\\u8A9E\\u7FA9\\u3002\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"All general-purpose servers MUST support the methods GET and HEAD. All other methods are OPTIONAL.\"), mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u6240\\u6709 server \\u5FC5\\u9808\\u652F\\u63F4 GET / HEAD \\u65B9\\u6CD5\\uFF0C\\u5176\\u4ED6\\u90FD\\u662F\\u53EF\\u9078\\u7684\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Additional methods, outside the scope of this specification, have been standardized for use in HTTP.  All such methods ought to be registered within the \\\"Hypertext Transfer Protocol (HTTP) Method Registry\\\" maintained by IANA, as defined in Section 8.1.\"), mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u672C RFC \\u6709\\u9810\\u5B9A\\u7FA9\\u4E86 8 \\u7A2E\\u65B9\\u6CD5\\uFF0C\\u5176\\u4ED6\\u7684\\u5728 \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://datatracker.ietf.org/doc/html/rfc7231#section-8.1\"\n  }, \"IANA\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The set of methods allowed by a target resource can be listed in an Allow header field (Section 7.4.1).  However, the set of allowed methods can change dynamically.  When a request method is received that is unrecognized or not implemented by an origin server, the origin server SHOULD respond with the 501 (Not Implemented) status code.  When a request method is received that is known by an origin server but not allowed for the target resource, the origin server SHOULD respond with the 405 (Method Not Allowed) status code.\"), mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u8CC7\\u6E90\\u5141\\u8A31\\u7684\\u64CD\\u4F5C\\u65B9\\u6CD5\\u53EF\\u4EE5\\u5217\\u5728 \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Allow\"), \" header \\u88E1\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://datatracker.ietf.org/doc/html/rfc7231#section-7.4.1\"\n  }, \"7.4.1\"), \" \\u5B9A\\u7FA9\\u7576\\u56DE 405 \\u72C0\\u614B\\u78BC\\u7684\\u6642\\u5019\\uFF0C\\u5FC5\\u9808\\u8981\\u6709 \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Allow\"), \" header\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u7576\\u6536\\u5230\\u4E00\\u500B\\u7121\\u6CD5\\u8B58\\u5225\\u6216\\u670D\\u52D9\\u6C92\\u6709\\u5BE6\\u73FE\\u7684\\u65B9\\u6CD5\\u6642\\uFF0C\\u8981\\u56DE 501 \\u72C0\\u614B\\u78BC\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u7576\\u6536\\u5230\\u4E00\\u500B\\u53EF\\u8B58\\u5225\\u4E14\\u6709\\u5BE6\\u4F5C\\u7684\\u65B9\\u6CD5\\uFF0C\\u4F46\\u8CC7\\u6E90\\u4E0D\\u5141\\u8A31\\u7684\\u64CD\\u4F5C\\u6642\\u8981\\u56DE 405 \\u72C0\\u614B\\u78BC\"))))));\n}\n;\nMDXContent.isMDXComponent = true;","rawBody":"[HTTP 1.1](https://datatracker.ietf.org/doc/html/rfc2616) ，以下筆記是參考 [RFC 7231](https://datatracker.ietf.org/doc/html/rfc7231)\n\n- 1997 發布第一版，1999 發布了第二版，也是用了 10 多年之久的 HTTP 1.1\n- > The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result.\n    - Method token 指出了 client 的目的，同時它也能預期 client 能拿得到的結果\n    - Method token 目前討論起來，感覺比較像 URI\n- > The request method's semantics might be further specialized by the semantics of some header fields when present in a request (Section 5) if those additional semantics do not conflict with the method.  For example, a client can send conditional request header fields (Section 5.2) to make the requested action conditional on the current state of the target resource ([RFC7232]).\n    - 某些 Header 語法只要不跟 Method 衝突，它都有可能會影響行為\n    - 像 IF-MATCH 之類的話法，會跟目標資源的狀態有關\n- > HTTP was originally designed to be usable as an interface to distributed object systems.  The request method was envisioned as applying semantics to a target resource in much the same way as invoking a defined method on an identified object would apply semantics.  The method token is case-sensitive because it might be used as a gateway to object-based systems with case-sensitive method names.\n    - HTTP 是被設計給分散式物件系統存取的介面，而 method 指的是會應用在資源上的方法。這就跟在某個類別上直接定義 method 並呼叫非常像。\n- > Unlike distributed objects, the standardized request methods in HTTP are not resource-specific, since uniform interfaces provide for better visibility and reuse in network-based systems [REST].  Once defined, a standardized method ought to have the same semantics when applied to any resource, though each resource determines for itself whether those semantics are implemented or allowed.\n    - 跟物件不一樣的是，HTTP 的請求方法並不是依賴於資源的特性，因為介面統一在網路系統上會有更好的可見性和重用性（參考 REST）。\n    - 一個統一的方法，應用在任何資源應該都具有相同的語義。\n- > All general-purpose servers MUST support the methods GET and HEAD. All other methods are OPTIONAL.\n    - 所有 server 必須支援 GET / HEAD 方法，其他都是可選的\n- > Additional methods, outside the scope of this specification, have been standardized for use in HTTP.  All such methods ought to be registered within the \"Hypertext Transfer Protocol (HTTP) Method Registry\" maintained by IANA, as defined in Section 8.1.\n    - 本 RFC 有預定義了 8 種方法，其他的在 [IANA](https://datatracker.ietf.org/doc/html/rfc7231#section-8.1)\n- > The set of methods allowed by a target resource can be listed in an Allow header field (Section 7.4.1).  However, the set of allowed methods can change dynamically.  When a request method is received that is unrecognized or not implemented by an origin server, the origin server SHOULD respond with the 501 (Not Implemented) status code.  When a request method is received that is known by an origin server but not allowed for the target resource, the origin server SHOULD respond with the 405 (Method Not Allowed) status code.\n    - 資源允許的操作方法可以列在 `Allow` header 裡\n        - [7.4.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.4.1) 定義當回 405 狀態碼的時候，必須要有 `Allow` header\n    - 當收到一個無法識別或服務沒有實現的方法時，要回 501 狀態碼\n    - 當收到一個可識別且有實作的方法，但資源不允許的操作時要回 405 狀態碼","excerpt":"HTTP 1.1  ，以下筆記是參考  RFC 7231 1997 發布第一版，1999 發布了第二版，也是用了 10 多年之久的 HTTP 1.1 The request method token is the primary source of request semant…","outboundReferences":[],"inboundReferences":[]},"tagsOutbound":{"nodes":[]}},"pageContext":{"tags":[],"slug":"/HTTP/1.1/","sidebarItems":[{"title":"Categories","items":[{"title":"About","url":"/","items":[]},{"title":"HTTP","url":"","items":[{"title":"0.9","url":"/HTTP/0.9/","items":[]},{"title":"1.0","url":"/HTTP/1.0/","items":[]},{"title":"1.1","url":"/HTTP/1.1/","items":[]},{"title":"HTTP","url":"/HTTP/HTTP/","items":[]}]},{"title":"Meetups","url":"","items":[{"title":"2022-02-24","url":"/meetups/2022-02-24/","items":[]},{"title":"2022-02-26","url":"/meetups/2022-02-26/","items":[]},{"title":"2022-03-03","url":"/meetups/2022-03-03/","items":[]},{"title":"2022-03-10","url":"/meetups/2022-03-10/","items":[]},{"title":"2022-03-19","url":"/meetups/2022-03-19/","items":[]},{"title":"2022-03-24","url":"/meetups/2022-03-24/","items":[]}]}]}],"tagsGroups":[],"latestPosts":[{"fields":{"slug":"/","title":"About","lastUpdatedAt":"2023-01-02T17:33:24.000Z","lastUpdated":"1/2/2023"},"frontmatter":{"draft":false,"tags":[]}},{"fields":{"slug":"/HTTP/HTTP/","title":"HTTP","lastUpdatedAt":"2023-01-02T17:33:24.000Z","lastUpdated":"1/2/2023"},"frontmatter":{"draft":false,"tags":[]}},{"fields":{"slug":"/HTTP/1.0/","title":"1.0","lastUpdatedAt":"2023-01-02T17:29:44.000Z","lastUpdated":"1/2/2023"},"frontmatter":{"draft":false,"tags":[]}},{"fields":{"slug":"/HTTP/0.9/","title":"0.9","lastUpdatedAt":"2023-01-02T17:29:44.000Z","lastUpdated":"1/2/2023"},"frontmatter":{"draft":false,"tags":[]}},{"fields":{"slug":"/HTTP/1.1/","title":"1.1","lastUpdatedAt":"2023-01-02T17:29:44.000Z","lastUpdated":"1/2/2023"},"frontmatter":{"draft":false,"tags":[]}},{"fields":{"slug":"/meetups/2022-02-24/","title":"2022-02-24","lastUpdatedAt":"2023-01-02T17:21:53.000Z","lastUpdated":"1/2/2023"},"frontmatter":{"draft":false,"tags":[]}},{"fields":{"slug":"/meetups/2022-02-26/","title":"2022-02-26","lastUpdatedAt":"2023-01-02T17:21:53.000Z","lastUpdated":"1/2/2023"},"frontmatter":{"draft":false,"tags":[]}},{"fields":{"slug":"/meetups/2022-03-03/","title":"2022-03-03","lastUpdatedAt":"2023-01-02T17:21:53.000Z","lastUpdated":"1/2/2023"},"frontmatter":{"draft":false,"tags":[]}},{"fields":{"slug":"/meetups/2022-03-10/","title":"2022-03-10","lastUpdatedAt":"2023-01-02T17:21:53.000Z","lastUpdated":"1/2/2023"},"frontmatter":{"draft":false,"tags":[]}},{"fields":{"slug":"/meetups/2022-03-19/","title":"2022-03-19","lastUpdatedAt":"2023-01-02T17:21:53.000Z","lastUpdated":"1/2/2023"},"frontmatter":{"draft":false,"tags":[]}}]}},
    "staticQueryHashes": ["2230547434","2320115945","3495835395","451533639"]}