{"data":{"allMdx":{"nodes":[{"fields":{"slug":"/","title":"About"},"frontmatter":{"draft":false},"rawBody":"# About\n\n我們是[蔣幹話軟體](https://ganhuaking.tw/)\n\n為了實踐樂於分享，我們預計每週四晚上 22:00 都會安排簡短的分享，這是很困難的任務，希望我們能一直持續下去。\n\n若有期望出現的主題，歡迎[許願](https://github.com/ganhuaking/meetups/discussions)或自告奮勇，但不保證會有成果。\n"},{"fields":{"slug":"/HTTP/1.0/","title":"1.0"},"frontmatter":{"draft":false},"rawBody":"- HTTP 0.9 出來之後，後來各家瀏覽器和伺服器都開始各自開幹，沒有統一標準，於是就會遇到不合規格的瀏覽器和伺服器無法正常運作的問題\n- 這份 RFC 的分類是 Informational，只是記錄各家常見的實作為何而已，還不算是標準，下一版的 HTTP 1.1 才是。"},{"fields":{"slug":"/HTTP/0.9/","title":"0.9"},"frontmatter":{"draft":false},"rawBody":"\n- [1991](https://www.w3.org/Protocols/HTTP/AsImplemented.html) 年發布最初的版本\n    - > This request consists of the word \"GET\", a space, the [document address](https://www.w3.org/Addressing/BNF.html#1) , omitting the \"http:, host and port parts when they are the coordinates just used to make the connection. (If a gateway is being used, then a full document address may be given specifying a different naming scheme).\n        - 這裡提到 request 由下面三個部分組成\n            - `GET`\n            - ` `（空格）\n            - 文件位址（document address），但省略 `http:`、主機、端口（Port）\n        - 若有 gateway，有可能會有不同命名的 scheme。\n          collapsed:: true\n            - #+BEGIN_NOTE\n              這裡討論後，推測是指 proxy 的架構有可能會是這樣。\n              #+END_NOTE\n        - 一個簡單的範例：\n          ```\n          GET /user\n          ```\n    - > The document address will consist of a single word (ie no spaces). If any further words are found on the request line, they MUST either be ignored, or else treated according to the [full HTTP spec](https://www.w3.org/Protocols/HTTP/HTTP2.html) .\n        - 文件位址是一個不帶空格的字串，超過的部分會被忽略。\n- [1992](https://www.w3.org/Protocols/HTTP/HTTP2.html) 基本 HTTP 的定義\n    - [Methods](https://www.w3.org/Protocols/HTTP/Methods.html) 定義\n        - GET\n            - > means retrieve whatever data is identified by the URI, so where the URI refers to a data-producing process, or a script which can be run by such a process, it is this data which will be returned, and not the source text of the script or process. Also used for searches .\n            - 使用 GET 會取得一份 URI 所標識的資料。URI 會對應到生成資料的進程（process）或類似進程執行的腳本（script），執行完後再返回資料。而不是回傳進程或腳本的原始碼。\n            - 舉反例：Apache + PHP 若沒開 mod_php 的話，就會回傳 PHP 的原始碼，這可能就會不符合 GET 的定義。\n        - HEAD\n            - > is the same as GET but returns only HTTP headers and no document body.\n            - 跟 GET 一樣，但只回 header，而不回應 body\n        - CHECKOUT\n            - > Similar to GET but locks the object against update by other people. The lock may be broken by a higher authority or on timeout: in this case a future CHECKIN will fail. ( Phase out? )\n            - 類似 GET ，但會將物件上鎖（lock）以防止其他人更新。上鎖可能會失敗，比方說已經比上鎖，或是逾時（timeout）\n        - SHOWMETHOD\n            - > Returns a description (perhaps a form) for a given method when applied to the given object. The method name is specified in a For-Method: field. (TBS)\n            - LATER 討論後，覺得它跟 `OPTIONS` 很像，等之後回頭來研究\n        - PUT\n            - > specifies that the data in the body section is to be stored under the supplied URL. The URL must already exist. The new contenst of the document are the data part of the request. POST and REPLY should be used for creating new documents.\n            - 指定 body 裡的 data 去儲存到對應的 URL 裡，URL 必須已存在。新的文件內容將會是資料的一部分。而 `POST` 和 `REPLY` 則是建立新文件。\n        - DELETE\n            - > Requests that the server delete the information corresponding to the given URL. After a successfull DELETE method, the URL becomes invalid for any future methods.\n            - 要求伺服器刪除給定 URL 的資訊。刪除後，後續 URL 在操作任何 method 都要是非法的。\n        - POST\n            - > Creates a new object linked to the specified object. The message-id field of the new object may be set by the client or else will be given by the server. A URL will be allocated by the server and returned to the client. The new document is the data part of the request. It is considered to be subordinate to the specified object, in the way that a file is subordinate to a directory containing it, or a news article is subordinate to a newsgroup to which it is posted.\n            - 建立連結到指定物件的新物件，伺服器會分配新的 URL 並返回。\n            - 討論認為，最後一句話比較好懂：「一個文章從屬於群組」，這是連結物件階層上的意義。\n        - LINK\n            - > Links an existing object to the specified object.\n            - 參考 POST，這是連結已存在的物件。\n        - UNLINK\n            - > Removes link (or other meta-) information from an object.\n            - 參考 LINK，這是取消連結。\n        - CHECKIN\n            - > Similar to PUT, but releases the lock set on the object. Fails if no lock has been set by CHECKOUT. Suggestion : phase out this (rcs-like) model in favor of the PUT (cvs-like, non-locking) model of code management.\n            - 與 CHECKOUT 相關，這是指釋放對物件上的鎖。如果先前沒有用 CHECKOUT 上鎖的話，則會失敗。\n            - 這裡提到了 [RCS](https://dywang.csie.cyut.edu.tw/dywang/linuxProgram/node117.html) 與 CVS 兩個關鍵字，指的是版本控制的概念\n        - TEXTSEARCH\n            - > The object may be queried with a text string. The search form of the GET method is used to query the object.\n            - 這裡看不出用途，但推測是一個設定的方法，如\n              \n              ```\n              TEXTSEARCH /user\n              GET /user?miles+chou\n              ```\n        - SPACEJUMP\n            - > The object will accept a query whose terms are the cooridnates of a point within the object. The method is implemented using GET with a derived URL .\n            - 這個東西就太神奇了，網站上查到的資料是，若資料有三維空間概念的話，可以用這個方法去取對應座標的資料。\n        - SEARCH\n            - > Proposed only. The index (etc) identified by the URL is to be searched for something matching in some sense the enclosed message. How does the client know what message fromats are acceptable to the server? (Suggestion of Fred Williams)\n            - 這段很難懂，因為只是個建議，也沒有範例。看建議內容推測，最初的問題在於要如何知道 server 可接受的參數或格式？現在常見的做法像是提供 Swagger 文件，或是實作 [HATEOAS](https://openhome.cc/Gossip/Spring/HATEOAS.html) 的概念，讓 API 的回傳成為文件，也有助於解決最初的問題。"},{"fields":{"slug":"/HTTP/1.1/","title":"1.1"},"frontmatter":{"draft":false},"rawBody":"[HTTP 1.1](https://datatracker.ietf.org/doc/html/rfc2616) ，以下筆記是參考 [RFC 7231](https://datatracker.ietf.org/doc/html/rfc7231)\n\n- 1997 發布第一版，1999 發布了第二版，也是用了 10 多年之久的 HTTP 1.1\n- > The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result.\n    - Method token 指出了 client 的目的，同時它也能預期 client 能拿得到的結果\n    - Method token 目前討論起來，感覺比較像 URI\n- > The request method's semantics might be further specialized by the semantics of some header fields when present in a request (Section 5) if those additional semantics do not conflict with the method.  For example, a client can send conditional request header fields (Section 5.2) to make the requested action conditional on the current state of the target resource ([RFC7232]).\n    - 某些 Header 語法只要不跟 Method 衝突，它都有可能會影響行為\n    - 像 IF-MATCH 之類的話法，會跟目標資源的狀態有關\n- > HTTP was originally designed to be usable as an interface to distributed object systems.  The request method was envisioned as applying semantics to a target resource in much the same way as invoking a defined method on an identified object would apply semantics.  The method token is case-sensitive because it might be used as a gateway to object-based systems with case-sensitive method names.\n    - HTTP 是被設計給分散式物件系統存取的介面，而 method 指的是會應用在資源上的方法。這就跟在某個類別上直接定義 method 並呼叫非常像。\n- > Unlike distributed objects, the standardized request methods in HTTP are not resource-specific, since uniform interfaces provide for better visibility and reuse in network-based systems [REST].  Once defined, a standardized method ought to have the same semantics when applied to any resource, though each resource determines for itself whether those semantics are implemented or allowed.\n    - 跟物件不一樣的是，HTTP 的請求方法並不是依賴於資源的特性，因為介面統一在網路系統上會有更好的可見性和重用性（參考 REST）。\n    - 一個統一的方法，應用在任何資源應該都具有相同的語義。\n- > All general-purpose servers MUST support the methods GET and HEAD. All other methods are OPTIONAL.\n    - 所有 server 必須支援 GET / HEAD 方法，其他都是可選的\n- > Additional methods, outside the scope of this specification, have been standardized for use in HTTP.  All such methods ought to be registered within the \"Hypertext Transfer Protocol (HTTP) Method Registry\" maintained by IANA, as defined in Section 8.1.\n    - 本 RFC 有預定義了 8 種方法，其他的在 [IANA](https://datatracker.ietf.org/doc/html/rfc7231#section-8.1)\n- > The set of methods allowed by a target resource can be listed in an Allow header field (Section 7.4.1).  However, the set of allowed methods can change dynamically.  When a request method is received that is unrecognized or not implemented by an origin server, the origin server SHOULD respond with the 501 (Not Implemented) status code.  When a request method is received that is known by an origin server but not allowed for the target resource, the origin server SHOULD respond with the 405 (Method Not Allowed) status code.\n    - 資源允許的操作方法可以列在 `Allow` header 裡\n        - [7.4.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.4.1) 定義當回 405 狀態碼的時候，必須要有 `Allow` header\n    - 當收到一個無法識別或服務沒有實現的方法時，要回 501 狀態碼\n    - 當收到一個可識別且有實作的方法，但資源不允許的操作時要回 405 狀態碼"},{"fields":{"slug":"/HTTP/HTTP/","title":"HTTP"},"frontmatter":{"draft":false},"rawBody":"[[RFC 9110]]\n\n[[Representations]]\n\n[[HTTP Method]]\n\n[[Message]]\n\n[[HTTP 協定]]\n\n[[實作 Web 身分驗證]]\n\n[[HTTP 特性]]\n\n[[編碼與解碼]]\n\n[[無狀態]]\n\n[[明文傳輸]]\n\n[[Cookie 機制]]\n\n[[SSL／TLS]]\n\n[[HTTP 發展歷史]]\n\n"},{"fields":{"slug":"/meetups/2022-02-24/","title":"2022-02-24"},"frontmatter":{"draft":false},"rawBody":"- Ganhuaking Meetups 15 感謝 #Miles 分享 [[Makefile]] 使用經驗\n    - [簡報分享](https://hackmd.io/@ganhuaking/meetups-15-slide)\n    - [筆記共編](https://hackmd.io/@mileschou/meetups-15/edit)\n- 下禮拜三 [[2022-03-03]] 將會由 #東哥 分享[[區塊鍊]]的知識，[傳送門](https://discord.com/events/546392426122575874/945920179190255636)"},{"fields":{"slug":"/meetups/2022-02-26/","title":"2022-02-26"},"frontmatter":{"draft":false},"rawBody":"直播分享將 Obsidian 所產出的靜態網頁，透過 [[GitHub Actions]] 部署上 [[GitHub Pages]]\n\n - GitHub Actions 的[參考資料](https://github.com/logseq/docs/blob/master/.github/workflows/gh-pages.yml)\n    - Sub Domain 設定的[參考解法](https://stackoverflow.com/questions/46455900/subdomain-of-website-for-github-pages-project)，放心大膽地把 Domain 設定下去就對了\n        - GitHub Pages 設定 custom domain 為 `meetups.ganhuaking.tw`\n        - GitHub Pages 會檢查 DNS 設定是否正確\n        - DNS 設定新的一筆 CNAME 記錄，Sub domain 設定 `meetups`，Target 設定 `ganhuaking.github.io`\n        - 最終再回 GitHub Pages 裡確認 DNS 檢查是否正確"},{"fields":{"slug":"/meetups/2022-03-03/","title":"2022-03-03"},"frontmatter":{"draft":false},"rawBody":"- 感謝今天東哥的分享\n- 下禮拜 [[2022-03-07]] 來挑戰複雜的線上分享，將邀請各位參與者討論版控與部署策略"},{"fields":{"slug":"/meetups/2022-03-10/","title":"2022-03-10"},"frontmatter":{"draft":false},"rawBody":"#Miles 主持的版控策略大亂鬥活動\n- [筆記共編](https://hackmd.io/5cYM6vdVRwu-xjI2G9jCiA)\n    - 執行流程\n    - 參與者都會被列入抽獎名單\n    - 被抽到要講的內容：\n        - 簡單自我介紹，至少講職位，與寫什麼語言的程式\n        - 目前公司或曾看過的版控流程，有需要的話可以分享畫面\n        - 版控流程對應到的上線流程\n        - QA 時間\n- #Gson\n    - 版控使用 GitLab Flow\n    - Release 的時候會選擇幾個重要的功能併上去\n- #VP\n    - 版控與 CD 切開，為了避免 push 去影響其他環境，包括測試環境\n    - 佈版方式可以參考: <https://github.com/VdustR/likftc/blob/8f402f0/.github/workflows/build.yml#L34>\n- #Sean\n    - 不同的客戶開不同的 branch\n- #JJ 與 #雷N\n    - 從 Master 開 feature branch 再發 PR 回 Master，要上線的時候再 merge 進 release branch\n    - feature 回 master 使用 rebase，hotfix 使用 squash。\n    - hotfix 上 release 用 cherry-pick\n    - ![](https://i.imgur.com/gbgJpZD.png)\n- #Ban\n    - 一條線\n    - 部屬是進機器再 pull 程式碼（PHP）下來，若有套件依賴的話，會人工處理\n- #QQBoxy aka QQ\n    - 全端工程師，Node.js\n    - 採用 GitLab Flow\n    - 人工進客戶主機部署 + 測試\n    - 測試有問題，會使用 featrue toggle 關閉功能。\n    - 開 Issue 就會開對應的 feature branch，開 Merge Resuest 後會 Code Review，Issue 若 Merge 回 master 後會跑 Unit Test。\n    - 佈署的部分會根據不同 OEM 有不同方式，有合作研發關係的 OEM 會先進 rc branch 再進 production，只是簡單修改的會直接進 production。\n    - 當進到 rc branch 後，並不會全自動封裝，我們會透過公司自己寫的封裝工具，封裝好一個版本後，再人工丟到對方的 Test Server 去佈署。\n    - 我們的 TE 與 客戶的合作團隊 會在 RC Server 做測試，Release 的部分，則直接 e2e 測試。\n    - 客戶當下測試有問題的話，有 Feature Toggle 就會直接關掉，沒有的話就人工降版回去。\n- #William\n    - ![](https://i.imgur.com/HSe54bw.png)\n- #邊緣人\n    - 使用 Git Flow\n    - #QQBoxy 請問一下，由於我們 Jira 是 TE 團隊在用，會由主管從 Jira 上面把  Issue 整理後建到 IT 團隊的 Gitlab Issue，想請問你們有什麼好方法做 Issue 的關聯嗎?\n        - A: 在 commit 時，就同時把 Gitlab Number 與 Jira Number Key 上去來做關聯。\n- #Mandy\n    - Jira 多個單與 Gitlab Issue 的關聯\n\n預告\n- [[2022-03-17]] #Gson 分享的 [[Minikube]] 手把手分享\n- #Miles 主持的 API 規格大亂鬥，從本次的版控策略大亂鬥分享的靈感，籌備中"},{"fields":{"slug":"/meetups/2022-03-19/","title":"2022-03-19"},"frontmatter":{"draft":false},"rawBody":"今天臨時加開了一場閒聊 [[HTTP]] method 定義。"},{"fields":{"slug":"/meetups/2022-03-24/","title":"2022-03-24"},"frontmatter":{"draft":false},"rawBody":"今天看了 [[HTTP]] 1.1 ，http method 的第一小節 overview"},{"fields":{"slug":"/placeholder/","title":"This Is a Placeholder File for Mdx"},"frontmatter":{"draft":true},"rawBody":"---\ntitle: This Is a Placeholder File for Mdx\ndraft: true\ntags:\n  - gatsby-theme-primer-wiki-placeholder\n---\n"}]}}}